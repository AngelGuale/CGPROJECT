<!DOCTYPE>

<html>
<!-- <script type="text/javascript" src="js/webgl-utils.js"></script>
 --><script type="text/javascript" src="js/twgl-full.min.js"></script>
<script type="text/javascript" src="js/chroma.min.js"></script>

<!-- <script type="text/javascript" src="js/primitives.js"></script>
 -->
<script type="text/javascript" src="js/jquery.min.js"></script>
<!--
    <script id="vshader" type="x-shader/x-vertex">
        uniform mat4 u_modelViewProjMatrix;
        uniform mat4 u_normalMatrix;
        uniform vec3 lightDir;

        attribute vec3 vNormal;
        attribute vec4 vTexCoord;
        attribute vec4 vPosition;

        varying float v_Dot;
        varying vec2 v_texCoord;

        void main()
        {
            gl_Position = u_modelViewProjMatrix * vPosition;
            v_texCoord = vTexCoord.st;
            vec4 transNormal = u_normalMatrix * vec4(vNormal,1);
            v_Dot = max(dot(transNormal.xyz, lightDir), 0.0);
        }
    </script>

    <script id="fshader" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D sampler2d;

        varying float v_Dot;
        varying vec2 v_texCoord;

        void main()
        {
            vec4 color = texture2D(sampler2d,v_texCoord);
            color += vec4(0.1,0.1,0.1,1);
            gl_FragColor = vec4(color.xyz * v_Dot, color.a);
        }
    </script>
-->


  <script id="vs" type="notjs">
uniform mat4 u_worldViewProjection;
uniform vec3 u_lightWorldPos;
uniform mat4 u_world;
uniform mat4 u_viewInverse;
uniform mat4 u_worldInverseTranspose;

attribute vec4 a_position;
attribute vec3 a_normal;
attribute vec2 a_texcoord;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

void main() {
  v_texCoord = a_texcoord;
  v_position = (u_worldViewProjection * a_position);
  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;
  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;
  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;
  gl_Position = v_position;
}
  </script>
  <script id="fs" type="notjs">
precision mediump float;

varying vec4 v_position;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

uniform vec4 u_lightColor;
uniform vec4 u_diffuseMult;
uniform sampler2D u_diffuse;
uniform vec4 u_specular;
uniform float u_shininess;
uniform float u_specularFactor;

vec4 lit(float l ,float h, float m) {
  return vec4(1.0,
              abs(l),//max(l, 0.0),
              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,
              1.0);
}

void main() {
  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;
  vec3 a_normal = normalize(v_normal);
  vec3 surfaceToLight = normalize(v_surfaceToLight);
  vec3 surfaceToView = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLight + surfaceToView);
  vec4 litR = lit(dot(a_normal, surfaceToLight),
                    dot(a_normal, halfVector), u_shininess);
  vec4 outColor = vec4((
  u_lightColor * (diffuseColor * litR.y +
                u_specular * litR.z * u_specularFactor)).rgb,
      diffuseColor.a);
  gl_FragColor = outColor;
}
  </script>

<!--
<script>
    var g = {}; // globals

    function init()
    {
        // Initialize
        var gl = initWebGL(
            // The id of the Canvas Element
            "example");
        if (!gl) {
          return;
        }
        g.program = simpleSetup(
            gl,
            // The ids of the vertex and fragment shaders
            "vshader", "fshader",
            // The vertex attribute names used by the shaders.
            // The order they appear here corresponds to their index
            // used later.
            [ "vNormal", "vColor", "vPosition"],
            // The clear color and depth values
            [ 0, 0, 0, 1 ], 10000);

        // Set up a uniform variable for the shaders
        gl.uniform3f(gl.getUniformLocation(g.program, "lightDir"), 0, 0, 1);

          if (g.program) {
                g.u_normalMatrixLoc = gl.getUniformLocation(g.program, "u_normalMatrix");
                g.u_modelViewProjMatrixLoc = gl.getUniformLocation(g.program, "u_modelViewProjMatrix");
            }

        // Create a box. On return 'gl' contains a 'box' property with
        // the BufferObjects containing the arrays for vertices,
        // normals, texture coords, and indices.
        g.box = makeBox(gl);
        g.sphere = makeSphere(gl, 1, 30, 30);
        earthTexture = loadImageTexture(gl, "textura/baseball.jpg");

        /*

        // Set up the array of colors for the cube's faces
        var colors = new Uint8Array(
            [  0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,     // v0-v1-v2-v3 front
               1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,     // v0-v3-v4-v5 right
               0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,     // v0-v5-v6-v1 top
               1, 1, 0, 1,   1, 1, 0, 1,   1, 1, 0, 1,   1, 1, 0, 1,     // v1-v6-v7-v2 left
               1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,     // v7-v4-v3-v2 bottom
               0, 1, 1, 1,   0, 1, 1, 1,   0, 1, 1, 1,   0, 1, 1, 1 ]    // v4-v7-v6-v5 back
                                                );

        // Set up the vertex buffer for the colors
        g.box.colorObject = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.colorObject);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        // Create some matrices to use later and save their locations in the shaders
        g.mvMatrix = new J3DIMatrix4();
        g.u_normalMatrixLoc = gl.getUniformLocation(g.program, "u_normalMatrix");
        g.normalMatrix = new J3DIMatrix4();
        g.u_modelViewProjMatrixLoc =
                gl.getUniformLocation(g.program, "u_modelViewProjMatrix");
        g.mvpMatrix = new J3DIMatrix4();

        // Enable all of the vertex attribute arrays.
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
        gl.enableVertexAttribArray(2);

        // Set up all the vertex attributes for vertices, normals and colors
        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.vertexObject);
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.normalObject);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.colorObject);
        gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, false, 0, 0);

        // Bind the index array
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, g.box.indexObject);
        
        */
        return gl;
    }

    width = -1;
    height = -1;
    var requestId;

    function reshape(gl)
    {
        var canvas = document.getElementById('example');
        var windowWidth = window.innerWidth - 20;
        var windowHeight = window.innerHeight - 40;
        if (windowWidth == width && windowHeight == height)
            return;

        width = windowWidth;
        height = windowHeight;
        canvas.width = width;
        canvas.height = height;

        // Set the viewport and projection matrix for the scene
        gl.viewport(0, 0, width, height);
        g.perspectiveMatrix = new J3DIMatrix4();
        g.perspectiveMatrix.perspective(30, width/height, 1, 10000);
        g.perspectiveMatrix.lookat(0, 0, 7, 0, 0, 0, 0, 1, 0);
    }

    function drawPicture(gl)
    {   


        // Make sure the canvas is sized correctly.
        //reshape(gl);

        // Clear the canvas
       // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


        // Set up the array of colors for the cube's faces
        var colors = new Uint8Array(
            [  0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,     // v0-v1-v2-v3 front
               1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,     // v0-v3-v4-v5 right
               0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,     // v0-v5-v6-v1 top
               1, 1, 0, 1,   1, 1, 0, 1,   1, 1, 0, 1,   1, 1, 0, 1,     // v1-v6-v7-v2 left
               1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,     // v7-v4-v3-v2 bottom
               0, 1, 1, 1,   0, 1, 1, 1,   0, 1, 1, 1,   0, 1, 1, 1 ]    // v4-v7-v6-v5 back
                                                );

        // Set up the vertex buffer for the colors
        g.box.colorObject = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.colorObject);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        // Create some matrices to use later and save their locations in the shaders
        g.mvMatrix = new J3DIMatrix4();
        g.u_normalMatrixLoc = gl.getUniformLocation(g.program, "u_normalMatrix");
        g.normalMatrix = new J3DIMatrix4();
        g.u_modelViewProjMatrixLoc =
                gl.getUniformLocation(g.program, "u_modelViewProjMatrix");
        g.mvpMatrix = new J3DIMatrix4();

        // Enable all of the vertex attribute arrays.
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
        gl.enableVertexAttribArray(2);

        // Set up all the vertex attributes for vertices, normals and colors
        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.vertexObject);
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.normalObject);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, g.box.colorObject);
        gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, false, 0, 0);

        // Bind the index array
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, g.box.indexObject);
        

        // Make a model/view matrix.
        g.mvMatrix.makeIdentity();
        g.mvMatrix.rotate(20, 1,0,0);
        g.mvMatrix.rotate(currentAngle, 0,1,0);

        // Construct the normal matrix from the model-view matrix and pass it in
        g.normalMatrix.load(g.mvMatrix);
        g.normalMatrix.invert();
        g.normalMatrix.transpose();
        g.normalMatrix.setUniform(gl, g.u_normalMatrixLoc, false);

        // Construct the model-view * projection matrix and pass it in
        g.mvpMatrix.load(g.perspectiveMatrix);
        g.mvpMatrix.multiply(g.mvMatrix);
        g.mvpMatrix.setUniform(gl, g.u_modelViewProjMatrixLoc, false);


        gl.bindTexture(gl.TEXTURE_2D, earthTexture);
        
        // Draw the cube
        gl.drawElements(gl.TRIANGLES, g.box.numIndices, gl.UNSIGNED_BYTE, 0);

        // Show the framerate
       // framerate.snapshot();

        currentAngle += incAngle;
        if (currentAngle > 360)
            currentAngle -= 360;
    }



        function drawOneEsfera(ctx, angle, x, y, z, scale, texture)
        {
            // setup VBOs
            ctx.enableVertexAttribArray(0);
            ctx.enableVertexAttribArray(1);
            ctx.enableVertexAttribArray(2);

            ctx.bindBuffer(ctx.ARRAY_BUFFER, g.sphere.vertexObject);
            ctx.vertexAttribPointer(2, 3, ctx.FLOAT, false, 0, 0);

            ctx.bindBuffer(ctx.ARRAY_BUFFER, g.sphere.normalObject);
            ctx.vertexAttribPointer(0, 3, ctx.FLOAT, false, 0, 0);

            ctx.bindBuffer(ctx.ARRAY_BUFFER, g.sphere.texCoordObject);
            ctx.vertexAttribPointer(1, 2, ctx.FLOAT, false, 0, 0);

            ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, g.sphere.indexObject);

            // generate the model-view matrix
            var mvMatrix = new J3DIMatrix4();
            mvMatrix.translate(x,y,z);
            mvMatrix.rotate(30, 1,0,0);
            mvMatrix.rotate(angle, 0,1,0);
            mvMatrix.scale(scale, scale, scale);

            // construct the normal matrix from the model-view matrix
            var normalMatrix = new J3DIMatrix4(mvMatrix);
            normalMatrix.invert();
            normalMatrix.transpose();
            normalMatrix.setUniform(ctx, g.u_normalMatrixLoc, false);

            // construct the model-view * projection matrix
            var mvpMatrix = new J3DIMatrix4(g.perspectiveMatrix);
            mvpMatrix.multiply(mvMatrix);
            mvpMatrix.setUniform(ctx, g.u_modelViewProjMatrixLoc, false);

            ctx.bindTexture(ctx.TEXTURE_2D, texture);
            ctx.drawElements(ctx.TRIANGLES, g.sphere.numIndices, ctx.UNSIGNED_SHORT, 0);
        }

        function drawFiguras(ctx)
        {
            reshape(ctx);
            ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);

           // drawOne(ctx, currentAngle, -1, 0, 0, 1, earthTexture);
           // drawOne(ctx, -currentAngle, 1, 0, 0, 0.6, earthTexture);
           drawOneEsfera(ctx, -currentAngle, 3, 0, 0, 0.6, earthTexture);
           drawPicture(ctx);
            
            //framerate.snapshot();

            currentAngle += incAngle;
            if (currentAngle > 360)
                currentAngle -= 360;
        }

    function start()
    {
        var c = document.getElementById("example");
        var w = Math.floor(window.innerWidth * 0.9);
        var h = Math.floor(window.innerHeight * 0.9);

        //c = WebGLDebugUtils.makeLostContextSimulatingCanvas(c);
        // tell the simulator when to lose context.
        //c.loseContextInNCalls(15);

        c.addEventListener('webglcontextlost', handleContextLost, false);
        c.addEventListener('webglcontextrestored', handleContextRestored, false);

        c.width = w;
        c.height = h;

        var gl = init();
        if (!gl) {
          return;
        }
        currentAngle = 0;
        incAngle = 0.5;
        //framerate = new Framerate("framerate");
        var f = function() {
          drawFiguras(gl);
           
           // drawPicture(gl);
            //drawOne(gl, currentAngle, -1, 0, 0, 1, earthTexture);
            requestId = window.requestAnimFrame(f, c);
        };
        f();

        function handleContextLost(e) {
            e.preventDefault();
            if (requestId !== undefined) {
                window.cancelAnimFrame(requestId);
                requestId = undefined;
            }
        }

        function handleContextRestored() {
            init();
            f();
        }
    }



</script>
-->

<body onload="">
    <button id="cubo" >Cubo</button>
        <button id="esfera">esfera</button>
<canvas id="c">
    If you're seeing this your web browser doesn't support the &lt;canvas>&gt; element. Ouch!
</canvas>
</body>

<script type="text/javascript" src="js/main.js"></script>

<script >
    $("#cubo").click(function(){
        

    });
</script>
</html>